import { NextResponse } from 'next/server';
import { ZodError } from 'zod';

import { ResourceType, ErrorType, ERROR_MESSAGES } from '../constants';

/**
 * Custom error class with error type
 */
export class ApiError extends Error {
  details?: any;
  status: number;
  code: ErrorType;
  type: ErrorType; // Added for compatibility with nested version

  constructor(code: ErrorType, message?: string, details?: any) {
    super(message || ERROR_MESSAGES[code]);

    this.name = 'ApiError';
    this.code = code;
    this.type = code; // Set type = code for backward compatibility
    this.details = details;
    this.status = this.getStatusCode(code);
  }

  /**
   * Map error types to HTTP status codes
   */
  private getStatusCode(type: ErrorType): number {
    switch (type) {
      case ErrorType.NOT_FOUND:
        return 404;
      case ErrorType.AUTHENTICATION:
        return 401;
      case ErrorType.AUTHORIZATION:
        return 403;
      case ErrorType.VALIDATION:
      case ErrorType.BAD_REQUEST:
      case ErrorType.INVALID_PARAM:
      case ErrorType.MISSING_PARAM:
        return 400;
      case ErrorType.RATE_LIMITED:
        return 429;
      case ErrorType.SERVER_ERROR:
      case ErrorType.DATABASE_ERROR:
      default:
        return 500;
    }
  }

  // Helper for resource not found errors
  static notFound(resource: ResourceType | string, id?: string): ApiError {
    return new ApiError(
      ErrorType.NOT_FOUND,
      `${resource} not found`,
      id ? { id } : undefined
    );
  }

  // Helper for database-related errors
  static database(message?: string, details?: any): ApiError {
    return new ApiError(
      ErrorType.DATABASE_ERROR,
      message || ERROR_MESSAGES[ErrorType.DATABASE_ERROR],
      details
    );
  }

  // Helper for unauthorized errors
  static unauthorized(message?: string): ApiError {
    return new ApiError(
      ErrorType.AUTHORIZATION,
      message || ERROR_MESSAGES[ErrorType.AUTHORIZATION]
    );
  }

  // Helper for authentication errors
  static unauthenticated(message?: string): ApiError {
    return new ApiError(
      ErrorType.AUTHENTICATION,
      message || ERROR_MESSAGES[ErrorType.AUTHENTICATION]
    );
  }

  // Helper for validation errors
  static validation(details: any): ApiError {
    return new ApiError(
      ErrorType.VALIDATION,
      ERROR_MESSAGES[ErrorType.VALIDATION],
      details
    );
  }

  // Helper for invalid parameter errors
  static invalidParam(param: string, message?: string): ApiError {
    return new ApiError(
      ErrorType.INVALID_PARAM,
      message || `Invalid value for parameter: ${param}`,
      { param }
    );
  }

  // Helper for missing parameter errors
  static missingParam(param: string | string[]): ApiError {
    const params = Array.isArray(param) ? param : [param];
    const paramList = params.join(', ');
    return new ApiError(
      ErrorType.MISSING_PARAM,
      `Missing required parameter${params.length > 1 ? 's' : ''}: ${paramList}`,
      { params }
    );
  }

  /**
   * Format the error for HTTP response
   * (Added from lib/api/response.ts)
   */
  toResponse() {
    return {
      error: {
        type: this.type,
        message: this.message,
        ...(this.details && { details: this.details })
      }
    };
  }
}

/**
 * Standard success response format
 */
export function successResponse<T>(data: T, status = 200) {
  return NextResponse.json(
    { success: true, data },
    { status }
  );
}

/**
 * Standard error response format
 */
export function errorResponse(message: string, status = 500, details?: any) {
  return NextResponse.json(
    { 
      success: false, 
      error: { 
        message,
        ...(details ? { details } : {})
      } 
    },
    { status }
  );
}

/**
 * Error response from ApiError
 */
export function apiErrorResponse(error: ApiError) {
  return NextResponse.json(
    {
      success: false,
      error: {
        code: error.code,
        message: error.message,
        ...(error.details ? { details: error.details } : {})
      }
    },
    { status: error.status }
  );
}

/**
 * Convert a Zod error to an ApiError
 * (Added from lib/api/response.ts)
 */
export function handleZodError(error: ZodError): ApiError {
  // Format the validation errors in a more user-friendly way
  const details = error.errors.reduce((acc, curr) => {
    const path = curr.path.join('.');
    acc[path] = curr.message;
    return acc;
  }, {} as Record<string, string>);

  return new ApiError(
    ErrorType.VALIDATION,
    'Validation error',
    details
  );
}

/**
 * Safely validate input with a Zod schema and handle errors
 * (Added from lib/api/response.ts)
 */
export async function validateWith<T, R>(
  schema: { parse: (data: T) => R },
  data: T
): Promise<R> {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof ZodError) {
      throw handleZodError(error);
    }
    throw error;
  }
}

/**
 * Wrapper for route handlers to simplify error handling
 * @param handler The route handler function
 * @returns A wrapped handler function with error handling
 */
export function withErrorHandling(handler: Function) {
  return async (...args: any[]) => {
    try {
      return await handler(...args);
    } catch (error) {
      console.error('API Error:', error);
      
      // Handle ApiError instances directly
      if (error instanceof ApiError) {
        return apiErrorResponse(error);
      }
      
      // Handle ZodError instances
      if (error instanceof ZodError) {
        return apiErrorResponse(handleZodError(error));
      }
      
      // Convert standard errors to ApiError based on message patterns
      if (error instanceof Error) {
        const message = error.message.toLowerCase();
        
        if (message.includes('not found')) {
          // Now using the actual ResourceType.RESOURCE enum value
          return apiErrorResponse(ApiError.notFound(ResourceType.RESOURCE));
        }
        
        if (message.includes('unauthorized') || message.includes('not authorized')) {
          return apiErrorResponse(ApiError.unauthorized());
        }
        
        if (message.includes('authentication') || message.includes('not authenticated')) {
          return apiErrorResponse(ApiError.unauthenticated());
        }
        
        if (message.includes('validation')) {
          return apiErrorResponse(ApiError.validation({ message: error.message }));
        }
      }
      
      // Default to generic server error
      return apiErrorResponse(new ApiError(ErrorType.SERVER_ERROR));
    }
  };
}

/**
 * Validate pagination parameters from search params
 */
export function validatePaginationParams(params: URLSearchParams) {
  const limit = params.get('limit');
  const offset = params.get('offset');
  const page = params.get('page');

  if (limit !== null && isNaN(Number(limit))) {
    throw ApiError.invalidParam('limit', 'Limit must be a number');
  }

  if (offset !== null && isNaN(Number(offset))) {
    throw ApiError.invalidParam('offset', 'Offset must be a number');
  }

  if (page !== null && isNaN(Number(page))) {
    throw ApiError.invalidParam('page', 'Page must be a number');
  }

  return {
    limit: limit !== null ? Math.min(Math.max(Number(limit), 1), 100) : 20,
    offset: offset !== null ? Math.max(Number(offset), 0) : (page !== null ? (Math.max(Number(page), 1) - 1) * (limit !== null ? Number(limit) : 20) : 0)
  };
}

/**
 * Validate required query parameters
 */
export function validateRequiredParams(params: URLSearchParams, required: string[]) {
  const missing = required.filter(param => !params.has(param));
  if (missing.length > 0) {
    throw ApiError.missingParam(missing);
  }
} 
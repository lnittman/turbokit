import { database } from '@repo/database';

import { ErrorType, ResourceType } from '../constants';
import { ApiError, validateWith } from '../lib/response';
import { 
  chatSchema, 
  chatMessageSchema, 
  createChatSchema,
  chatMessageCreateSchema,
  updateChatProjectSchema,
  fromPrisma,
  Chat,
  ChatMessage,
  CreateChatRequest,
  ChatMessageCreate,
  UpdateChatProjectRequest
} from '../schemas/chat';

import { projectService } from './project';

export class ChatService {
  /**
   * Get a chat by ID
   */
  async getChatById(chatId: string): Promise<Chat> {
    try {
      const chat = await database.chat.findUnique({
        where: { id: chatId }
      });
      
      if (!chat) {
        throw ApiError.notFound(ResourceType.CHAT, chatId);
      }
      
      return fromPrisma.chat(chat);
    } catch (error) {
      console.error('[ChatService.getChatById] Error fetching chat:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to fetch chat');
    }
  }

  /**
   * Get all chats for a user
   */
  async getUserChats(userId: string): Promise<Chat[]> {
    try {
      const chats = await database.chat.findMany({
        where: { userId },
        orderBy: { updatedAt: 'desc' }
      });
      
      return chats.map(fromPrisma.chat);
    } catch (error) {
      console.error('[ChatService.getUserChats] Error fetching user chats:', error);
      throw new ApiError(ErrorType.SERVER_ERROR, 'Failed to fetch user chats');
    }
  }

  /**
   * Get all chats for a project
   */
  async getProjectChats(projectId: string): Promise<Chat[]> {
    try {
      const chats = await database.chat.findMany({
        where: { projectId },
        orderBy: { updatedAt: 'desc' }
      });
      
      return chats.map(fromPrisma.chat);
    } catch (error) {
      console.error('[ChatService.getProjectChats] Error fetching project chats:', error);
      throw new ApiError(ErrorType.SERVER_ERROR, 'Failed to fetch project chats');
    }
  }

  /**
   * Create a new chat
   */
  async createChat(userId: string, data: CreateChatRequest): Promise<Chat> {
    try {
      // Validate input data
      const validatedData = await validateWith(createChatSchema, data);
      
      // Create the chat
      const newChat = await database.chat.create({
        data: {
          title: validatedData.title || 'New Chat',
          userId,
          projectId: validatedData.projectId,
        }
      });
      
      // If there's an initial message, create it
      if (validatedData.initialMessage) {
        await database.chatMessage.create({
          data: {
            chatId: newChat.id,
            userId,
            content: validatedData.initialMessage,
            type: 'user'
          }
        });
      }
      
      return fromPrisma.chat(newChat);
    } catch (error) {
      console.error('[ChatService.createChat] Error creating chat:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to create chat');
    }
  }

  /**
   * Get chat messages
   */
  async getChatMessages(chatId: string): Promise<ChatMessage[]> {
    try {
      // Verify chat exists
      await this.getChatById(chatId);
      
      // Get messages
      const messages = await database.chatMessage.findMany({
        where: { chatId },
        orderBy: { createdAt: 'asc' }
      });
      
      return messages.map(fromPrisma.chatMessage);
    } catch (error) {
      console.error('[ChatService.getChatMessages] Error fetching chat messages:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to fetch chat messages');
    }
  }

  /**
   * Add a message to a chat
   */
  async addChatMessage(chatId: string, userId: string, data: ChatMessageCreate): Promise<ChatMessage> {
    try {
      // Validate input data
      const validatedData = await validateWith(chatMessageCreateSchema, data);
      
      // Verify chat exists
      await this.getChatById(chatId);
      
      // Create message
      const newMessage = await database.chatMessage.create({
        data: {
          chatId,
          userId,
          content: validatedData.content,
          type: validatedData.type,
          mode: validatedData.mode
        }
      });
      
      // Update chat's updatedAt
      await database.chat.update({
        where: { id: chatId },
        data: { updatedAt: new Date() }
      });
      
      return fromPrisma.chatMessage(newMessage);
    } catch (error) {
      console.error('[ChatService.addChatMessage] Error adding chat message:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to add chat message');
    }
  }

  /**
   * Delete a chat and all its messages
   */
  async deleteChat(chatId: string, userId: string): Promise<void> {
    try {
      // Get the chat
      const chat = await this.getChatById(chatId);
      
      // Verify ownership
      if (chat.userId !== userId) {
        throw ApiError.unauthorized('You do not have permission to delete this chat');
      }
      
      // Delete the chat (will cascade delete messages due to Prisma schema)
      await database.chat.delete({
        where: { id: chatId }
      });
    } catch (error) {
      console.error('[ChatService.deleteChat] Error deleting chat:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to delete chat');
    }
  }

  /**
   * Helper function to limit the token size of message history
   */
  limitMessageHistory(messages: any[], maxMessages = 20) {
    if (!messages || messages.length <= maxMessages) {
      return messages;
    }
    
    // Always include the first system message if it exists
    const systemMessages = messages.filter(m => m.type === 'system' || m.role === 'system');
    const firstSystemMessage = systemMessages.length > 0 ? [systemMessages[0]] : [];
    
    // Take the most recent N-1 messages after preserving the system message
    const recentMessages = messages.slice(-1 * (maxMessages - firstSystemMessage.length));
    
    // Return system message (if any) + most recent messages
    return [...firstSystemMessage, ...recentMessages];
  }

  /**
   * Rename a chat
   */
  async renameChat(chatId: string, title: string, userId: string) {
    try {
      // Verify chat exists and user has access
      const chat = await this.getChatById(chatId);
      
      // Verify ownership
      if (chat.userId !== userId) {
        throw ApiError.unauthorized('You do not have permission to rename this chat');
      }
      
      const updatedChat = await database.chat.update({
        where: { id: chatId },
        data: { title }
      });
      
      return fromPrisma.chat(updatedChat);
    } catch (error) {
      console.error('[ChatService.renameChat] Error renaming chat:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to rename chat');
    }
  }

  /**
   * Save a message to the database
   */
  async saveMessage(chatId: string, content: string, type: 'user' | 'ai' | 'system', userId: string) {
    if (!chatId || !content.trim()) {
      console.log('[ChatService.saveMessage] Invalid input:', { chatId, contentLength: content?.length, type });
      throw new ApiError(ErrorType.BAD_REQUEST, 'Invalid message data');
    }
    
    console.log(`[ChatService.saveMessage] Saving ${type} message to database for chat:`, chatId);
    
    try {
      // Create the message
      const message = await database.chatMessage.create({
        data: {
          content,
          type,
          chatId,
          userId,
        }
      });

      // Update the chat's updatedAt timestamp
      await database.chat.update({
        where: { id: chatId },
        data: { updatedAt: new Date() }
      });
      
      console.log(`[ChatService.saveMessage] Saved ${type} message with ID:`, message.id);
      return message;
    } catch (error) {
      console.error('[ChatService.saveMessage] Error saving message:', error);
      throw new ApiError(ErrorType.SERVER_ERROR, 'Failed to save message');
    }
  }

  /**
   * Update a chat's project assignment
   */
  async updateChatProject(chatId: string, projectId: string | null | undefined, userId: string): Promise<Chat> {
    try {
      // Validate input data
      await validateWith(updateChatProjectSchema, { projectId });
      
      // Verify chat exists and user has access
      const chat = await this.getChatById(chatId);
      
      // Verify ownership
      if (chat.userId !== userId) {
        throw ApiError.unauthorized('You do not have permission to update this chat');
      }
      
      // If projectId is provided, verify it exists and user has access
      if (projectId) {
        const project = await projectService.getProjectById(projectId);
        const hasAccess = await projectService.verifyProjectOwnership(projectId, userId);
        
        if (!hasAccess) {
          throw ApiError.unauthorized('You do not have permission to assign this project');
        }
      }
      
      // Update the chat's project
      const updatedChat = await database.chat.update({
        where: { id: chatId },
        data: { projectId }
      });
      
      return fromPrisma.chat(updatedChat);
    } catch (error) {
      console.error('[ChatService.updateChatProject] Error updating chat project:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to update chat project');
    }
  }
}

// Export a singleton instance for use across the application
export const chatService = new ChatService();

// Exports for use in application
export const getChatById = (chatId: string) => chatService.getChatById(chatId);
export const getUserChats = (userId: string) => chatService.getUserChats(userId);
export const getProjectChats = (projectId: string) => chatService.getProjectChats(projectId);
export const createChat = (userId: string, data: CreateChatRequest) => chatService.createChat(userId, data);
export const getChatMessages = (chatId: string) => chatService.getChatMessages(chatId);
export const addChatMessage = (chatId: string, userId: string, data: ChatMessageCreate) => 
  chatService.addChatMessage(chatId, userId, data);
export const deleteChat = (chatId: string, userId: string) => chatService.deleteChat(chatId, userId);
export const updateChatProject = (chatId: string, projectId: string | null | undefined, userId: string) => 
  chatService.updateChatProject(chatId, projectId, userId);
export const limitMessageHistory = chatService.limitMessageHistory.bind(chatService);
export const renameChat = (chatId: string, title: string, userId: string) => 
  chatService.renameChat(chatId, title, userId);
export const saveMessage = chatService.saveMessage.bind(chatService);

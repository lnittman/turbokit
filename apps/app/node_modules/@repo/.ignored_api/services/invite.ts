import { randomUUID } from 'crypto';
import { addDays } from 'date-fns';

import { database } from '@repo/database';
import { resend, InviteEmailTemplate } from '@repo/email';

import { ErrorType } from '../constants';
import { validateWith } from '../lib/response';
import { ApiError } from '../lib/response';
import {
  chatInviteRequestSchema,
  projectInviteRequestSchema,
  AcceptInviteResponse,
  ChatInviteRequest,
  InviteDetailsResponse,
  ProjectInviteRequest,
} from '../schemas/invite';

export class InviteService {
  /**
   * Send invitations to join a chat
   */
  async sendChatInvites(
    chatId: string,
    inviteData: ChatInviteRequest,
    inviterId: string,
    inviterName: string,
    inviterEmail: string
  ): Promise<Array<{ email: string; status: string; inviteId?: string; message?: string; error?: string }>> {
    try {
      const validatedData = await validateWith(chatInviteRequestSchema, inviteData);

      const chat = await database.chat.findFirst({
        where: {
          id: chatId,
          OR: [
            { userId: inviterId },
            {
              participants: {
                some: {
                  userId: inviterId,
                  role: { in: ['OWNER', 'MODERATOR'] },
                }
              }
            }
          ]
        },
        include: {
          participants: true
        }
      });

      if (!chat) {
        throw new ApiError(
          ErrorType.NOT_FOUND,
          'Chat not found or you do not have permission to invite users'
        );
      }

      const inviteResults = await Promise.all(
        validatedData.emails.map(async (email: string) => {
          try {
            const trimmedEmail = email.toLowerCase().trim();
            const existingInvite = await database.chatInvite.findFirst({
                where: {
                    chatId: chatId,
                    inviteEmail: trimmedEmail,
                    accepted: false,
                    expiresAt: { gt: new Date() } 
                }
            });
            
            if(existingInvite) {
                 return { email: trimmedEmail, status: 'skipped', message: 'Invite already pending for this email' };
            }

            const inviteToken = randomUUID();
            const expiresAt = addDays(new Date(), 7);

            const chatInvite = await database.chatInvite.create({
              data: {
                chatId,
                invitedByUserId: inviterId,
                inviteEmail: trimmedEmail,
                inviteToken,
                role: validatedData.role,
                expiresAt,
              }
            });

            const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
            const inviteUrl = `${baseUrl}/invite/${inviteToken}`;

            await resend.emails.send({
              from: 'arbor <noreply@arbor.xyz>',
              to: trimmedEmail,
              subject: `${inviterName || 'Someone'} invited you to join a chat on arbor`,
              react: InviteEmailTemplate({
                inviterName: inviterName || inviterEmail,
                chatTitle: chat.title,
                inviteLink: inviteUrl
              })
            });

            return { email: trimmedEmail, status: 'sent', inviteId: chatInvite.id };
          } catch (error) {
            console.error(`[InviteService.sendChatInvites] Failed to send invite to ${email}:`, error);
            return { email, status: 'failed', error: error instanceof Error ? error.message : 'Unknown error' };
          }
        })
      );

      return inviteResults;
    } catch (error) {
      console.error('[InviteService.sendChatInvites] Error:', error);
      if (error instanceof ApiError) throw error;
      throw new ApiError(ErrorType.SERVER_ERROR, 'Failed to send chat invites');
    }
  }

  /**
   * Send invitations to join a project
   */
  async sendProjectInvites(
    projectId: string,
    inviteData: ProjectInviteRequest,
    inviterId: string,
    inviterName: string,
    inviterEmail: string
  ): Promise<Array<{ email: string; status: string; inviteId?: string; message?: string; error?: string }>> {
    try {
      const validatedData = await validateWith(projectInviteRequestSchema, inviteData);

      const project = await database.project.findFirst({
        where: {
          id: projectId,
          OR: [
            { userId: inviterId },
            {
              collaborators: {
                some: { userId: inviterId, role: 'OWNER' }
              }
            }
          ]
        },
         include: {
          collaborators: true
        }
      });

      if (!project) {
        throw new ApiError(
          ErrorType.NOT_FOUND,
          'Project not found or you do not have permission to invite users'
        );
      }

      const inviteResults = await Promise.all(
        validatedData.emails.map(async (email: string) => {
          try {
            const trimmedEmail = email.toLowerCase().trim();
            const existingInvite = await database.projectInvite.findFirst({
                where: {
                    projectId: projectId,
                    inviteEmail: trimmedEmail,
                    accepted: false,
                    expiresAt: { gt: new Date() } 
                }
            });
            
            if(existingInvite) {
                 return { email: trimmedEmail, status: 'skipped', message: 'Invite already pending for this email' };
            }

            const inviteToken = randomUUID();
            const expiresAt = addDays(new Date(), 7);

            const projectInvite = await database.projectInvite.create({
              data: {
                projectId,
                invitedByUserId: inviterId,
                inviteEmail: trimmedEmail,
                inviteToken,
                role: validatedData.role,
                expiresAt,
              }
            });

            const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
            const inviteUrl = `${baseUrl}/invite/${inviteToken}`;

            await resend.emails.send({
              from: 'arbor <noreply@arbor.xyz>',
              to: trimmedEmail,
              subject: `${inviterName || 'Someone'} invited you to collaborate on a project on arbor`,
              react: InviteEmailTemplate({
                inviterName: inviterName || inviterEmail,
                chatTitle: project.name, 
                inviteLink: inviteUrl
              })
            });

            return { email: trimmedEmail, status: 'sent', inviteId: projectInvite.id };
          } catch (error) {
            console.error(`[InviteService.sendProjectInvites] Failed to send invite to ${email}:`, error);
            if (error instanceof Error && (error.message.includes('projectInvite') || error.message.includes('projectCollaborator'))) {
              console.error("Database schema error likely: ProjectInvite/ProjectCollaborator models might be missing or mismatching.");
              return { email, status: 'failed', error: 'Database configuration error for project invites.' };
            }
            return { email, status: 'failed', error: error instanceof Error ? error.message : 'Unknown error' };
          }
        })
      );

      return inviteResults;
    } catch (error) {
      console.error('[InviteService.sendProjectInvites] Error:', error);
      if (error instanceof ApiError) throw error;
      throw new ApiError(ErrorType.SERVER_ERROR, 'Failed to send project invites');
    }
  }

  /**
   * Get invitation details by token (handles both project and chat invites)
   */
  async getInviteByToken(token: string): Promise<InviteDetailsResponse> {
    try {
      const projectInvite = await database.projectInvite.findUnique({
        where: { inviteToken: token },
        include: {
          project: { select: { id: true, name: true, description: true } },
          invitedBy: { select: { id: true } }
        }
      });

      if (projectInvite) {
        if (projectInvite.expiresAt < new Date()) {
          throw new ApiError(ErrorType.BAD_REQUEST, 'Invite has expired');
        }
        if (projectInvite.accepted) {
          throw new ApiError(ErrorType.BAD_REQUEST, 'Invite has already been accepted');
        }

        return {
          type: 'project',
          invite: {
            id: projectInvite.id,
            email: projectInvite.inviteEmail,
            role: projectInvite.role,
            expiresAt: projectInvite.expiresAt,
            createdAt: projectInvite.createdAt
          },
          project: {
            id: projectInvite.project.id,
            name: projectInvite.project.name,
            description: projectInvite.project.description || null
          },
          invitedBy: { id: projectInvite.invitedBy.id }
        };
      }

      const chatInvite = await database.chatInvite.findUnique({
        where: { inviteToken: token },
        include: {
          chat: { select: { id: true, title: true } },
          invitedBy: { select: { id: true } }
        }
      });

      if (chatInvite) {
        if (chatInvite.expiresAt < new Date()) {
          throw new ApiError(ErrorType.BAD_REQUEST, 'Invite has expired');
        }
        if (chatInvite.accepted) {
          throw new ApiError(ErrorType.BAD_REQUEST, 'Invite has already been accepted');
        }

        return {
          type: 'chat',
          invite: {
            id: chatInvite.id,
            email: chatInvite.inviteEmail,
            role: chatInvite.role,
            expiresAt: chatInvite.expiresAt,
            createdAt: chatInvite.createdAt
          },
          chat: {
            id: chatInvite.chat.id,
            title: chatInvite.chat.title
          },
          invitedBy: { id: chatInvite.invitedBy.id }
        };
      }

      throw ApiError.notFound('Invite not found or is invalid');

    } catch (error) {
      console.error('[InviteService.getInviteByToken] Error fetching invite:', error);
      if (error instanceof Error && (error.message.includes('projectInvite'))) {
         console.error("Database schema error likely: ProjectInvite model might be missing or mismatching.");
         throw new ApiError(ErrorType.SERVER_ERROR, 'Database configuration error for project invites.');
      }
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to fetch invite');
    }
  }

  /**
   * Accept an invitation (handles both project and chat)
   */
  async acceptInvite(token: string, dbUserId: string): Promise<AcceptInviteResponse> {
    try {
      const user = await database.user.findUnique({ where: { id: dbUserId } });
      if (!user) throw new ApiError(ErrorType.NOT_FOUND, 'User not found');

      const projectInvite = await database.projectInvite.findUnique({ 
          where: { inviteToken: token },
          include: { project: { select: { name: true }} }
      });

      if (projectInvite) {
          if (projectInvite.accepted) throw new ApiError(ErrorType.BAD_REQUEST, 'Invite already accepted');
          if (projectInvite.expiresAt < new Date()) throw new ApiError(ErrorType.BAD_REQUEST, 'Invite has expired');
          
          const collaboratorResult = await database.$transaction(async (tx) => {
            const collaborator = await tx.projectCollaborator.create({
              data: {
                projectId: projectInvite.projectId,
                userId: dbUserId,
                role: projectInvite.role
              }
            });

            await tx.projectInvite.update({
              where: { id: projectInvite.id },
              data: {
                accepted: true,
                acceptedAt: new Date(),
                acceptedByUserId: dbUserId,
                userId: dbUserId
              }
            });
            return collaborator;
          });

          return {
              type: 'project',
              collaborator: {
                  id: collaboratorResult.id,
                  projectId: collaboratorResult.projectId,
                  projectName: projectInvite.project.name,
                  userId: collaboratorResult.userId,
                  role: collaboratorResult.role,
                  createdAt: collaboratorResult.createdAt
              }
          };
      }
      
      const chatInvite = await database.chatInvite.findUnique({ 
          where: { inviteToken: token },
          include: { chat: { select: { title: true }} }
      });
      
      if (chatInvite) {
          if (chatInvite.accepted) throw new ApiError(ErrorType.BAD_REQUEST, 'Invite already accepted');
          if (chatInvite.expiresAt < new Date()) throw new ApiError(ErrorType.BAD_REQUEST, 'Invite has expired');

          const participantResult = await database.$transaction(async (tx) => {
              const existingParticipant = await tx.chatParticipant.findUnique({
                  where: { chatId_userId: { chatId: chatInvite.chatId, userId: dbUserId } }
              });
              if(existingParticipant) {
                  await tx.chatInvite.update({
                    where: { id: chatInvite.id },
                    data: {
                      accepted: true,
                      acceptedAt: new Date(),
                      acceptedByUserId: dbUserId,
                      userId: dbUserId
                    }
                  });
                  return existingParticipant;
              }
              
              const participant = await tx.chatParticipant.create({
                  data: {
                      chatId: chatInvite.chatId,
                      userId: dbUserId,
                      role: chatInvite.role,
                  }
              });

              await tx.chatInvite.update({
                  where: { id: chatInvite.id },
                  data: {
                      accepted: true,
                      acceptedAt: new Date(),
                      acceptedByUserId: dbUserId,
                      userId: dbUserId
                  }
              });
              return participant;
          });

          return {
              type: 'chat',
              participant: {
                  id: participantResult.id,
                  chatId: participantResult.chatId,
                  chatTitle: chatInvite.chat.title,
                  userId: participantResult.userId,
                  role: participantResult.role,
                  joinedAt: participantResult.joinedAt
              }
          };
      }
      
      throw ApiError.notFound('Invite not found, invalid, or expired');

    } catch (error) {
      console.error('[InviteService.acceptInvite] Error accepting invite:', error);
       if (error instanceof Error && (error.message.includes('projectInvite') || error.message.includes('projectCollaborator'))) {
         console.error("Database schema error likely: ProjectInvite/ProjectCollaborator models might be missing or mismatching.");
         throw new ApiError(ErrorType.SERVER_ERROR, 'Database configuration error for project invites.');
      }
      if (error instanceof ApiError) throw error;
      throw new ApiError(ErrorType.SERVER_ERROR, 'Failed to accept invite');
    }
  }
}

export const inviteService = new InviteService();

export const sendChatInvites = (
  chatId: string, 
  inviteData: ChatInviteRequest, 
  inviterId: string,
  inviterName: string,
  inviterEmail: string
) => inviteService.sendChatInvites(chatId, inviteData, inviterId, inviterName, inviterEmail);

export const sendProjectInvites = (
  projectId: string, 
  inviteData: ProjectInviteRequest, 
  inviterId: string,
  inviterName: string,
  inviterEmail: string
) => inviteService.sendProjectInvites(projectId, inviteData, inviterId, inviterName, inviterEmail);

export const getInviteByToken = (token: string): Promise<InviteDetailsResponse> => 
  inviteService.getInviteByToken(token);

export const acceptInvite = (token: string, dbUserId: string): Promise<AcceptInviteResponse> => 
  inviteService.acceptInvite(token, dbUserId); 
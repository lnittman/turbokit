import { database as db } from '@repo/database';

import { ResourceType, ErrorType } from '../constants';
import { validateWith, ApiError } from '../lib/response';
import { 
  createProjectSchema,
  updateProjectSchema,
  fromPrisma,
  Project,
  CreateProjectRequest,
  UpdateProjectRequest
} from '../schemas/project';

export class ProjectService {
  /**
   * Get a project by ID
   */
  async getProjectById(projectId: string): Promise<Project> {
    try {
      const project = await db.project.findUnique({
        where: { id: projectId }
      });
      
      if (!project) {
        throw ApiError.notFound(ResourceType.PROJECT, projectId);
      }
      
      return fromPrisma.project(project);
    } catch (error) {
      console.error('[ProjectService.getProjectById] Error fetching project:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to fetch project');
    }
  }

  /**
   * Get all projects for a user
   */
  async getUserProjects(userId: string): Promise<Project[]> {
    try {
      const projects = await db.project.findMany({
        where: { 
          OR: [
            { userId },
            {
              collaborators: {
                some: { userId }
              }
            }
          ]
        },
        orderBy: { updatedAt: 'desc' }
      });
      
      return projects.map(fromPrisma.project);
    } catch (error) {
      console.error('[ProjectService.getUserProjects] Error fetching user projects:', error);
      throw new ApiError(ErrorType.SERVER_ERROR, 'Failed to fetch user projects');
    }
  }

  /**
   * Create a new project
   */
  async createProject(userId: string, data: CreateProjectRequest): Promise<Project> {
    try {
      // Validate input data
      const validatedData = await validateWith(createProjectSchema, data);
      
      // Create the project
      const newProject = await db.project.create({
        data: {
          name: validatedData.name,
          description: validatedData.description,
          userId,
        }
      });
      
      return fromPrisma.project(newProject);
    } catch (error) {
      console.error('[ProjectService.createProject] Error creating project:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to create project');
    }
  }

  /**
   * Update a project
   */
  async updateProject(projectId: string, userId: string, data: UpdateProjectRequest): Promise<Project> {
    try {
      // Validate input data
      const validatedData = await validateWith(updateProjectSchema, data);
      
      // Get the project
      const project = await this.getProjectById(projectId);
      
      // Verify ownership or admin access
      const isOwner = await this.verifyProjectOwnership(projectId, userId);
      if (!isOwner) {
        throw ApiError.unauthorized('You do not have permission to update this project');
      }
      
      // Update the project
      const updatedProject = await db.project.update({
        where: { id: projectId },
        data: {
          name: validatedData.name ?? project.name,
          description: validatedData.description ?? project.description
        }
      });
      
      return fromPrisma.project(updatedProject);
    } catch (error) {
      console.error('[ProjectService.updateProject] Error updating project:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to update project');
    }
  }

  /**
   * Delete a project and all associated data
   */
  async deleteProject(projectId: string, userId: string): Promise<void> {
    try {
      // Verify ownership
      const isOwner = await this.verifyProjectOwnership(projectId, userId);
      if (!isOwner) {
        throw ApiError.unauthorized('You do not have permission to delete this project');
      }
      
      // Delete the project (cascade delete will handle related records)
      await db.project.delete({
        where: { id: projectId }
      });
    } catch (error) {
      console.error('[ProjectService.deleteProject] Error deleting project:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to delete project');
    }
  }

  /**
   * Verify if a user owns a project
   */
  async verifyProjectOwnership(projectId: string, userId: string): Promise<boolean> {
    try {
      const project = await db.project.findUnique({
        where: { id: projectId }
      });
      
      if (!project) {
        throw ApiError.notFound(ResourceType.PROJECT);
      }
      
      // Check direct ownership
      if (project.userId === userId) {
        return true;
      }
      
      // Check collaborator with OWNER role
      const collaborator = await db.projectCollaborator.findFirst({
        where: {
          projectId,
          userId,
          role: 'OWNER'
        }
      });
      
      return !!collaborator;
    } catch (error) {
      console.error('[ProjectService.verifyProjectOwnership] Error:', error);
      if (error instanceof ApiError) {
        throw error;
      }
      throw new ApiError(ErrorType.SERVER_ERROR, 'Failed to verify project ownership');
    }
  }
}

// Export a singleton instance for use across the application
export const projectService = new ProjectService();

// Exports for use in application
export const getProjectById = (projectId: string) => projectService.getProjectById(projectId);
export const getUserProjects = (userId: string) => projectService.getUserProjects(userId);
export const createProject = (userId: string, data: CreateProjectRequest) => projectService.createProject(userId, data);
export const updateProject = (projectId: string, userId: string, data: UpdateProjectRequest) => 
  projectService.updateProject(projectId, userId, data);
export const deleteProject = (projectId: string, userId: string) => projectService.deleteProject(projectId, userId);
export const verifyProjectOwnership = (projectId: string, userId: string) => 
  projectService.verifyProjectOwnership(projectId, userId); 
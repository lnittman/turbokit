import { randomUUID } from 'crypto';
import { database as db } from '@repo/database';

import { ResourceType, ErrorType } from '../constants';
import { validateWith, ApiError } from '../lib/response';
import {
  sharedLinkSchema,
  createSharedLinkSchema,
  sharedLinkResponseSchema,
  sharedChatContentSchema,
  fromPrisma,
  SharedLink,
  CreateSharedLinkRequest,
  SharedLinkResponse,
  SharedChatContent
} from '../schemas/share';

export class ShareService {
  /**
   * Create a new shared link for a chat
   */
  async createSharedLink(userId: string, data: CreateSharedLinkRequest): Promise<SharedLinkResponse> {
    try {
      // Validate input data
      const validatedData = await validateWith(createSharedLinkSchema, data);
      
      // Check if the chat exists and belongs to the user (using DB userId)
      const chat = await db.chat.findFirst({
        where: {
          id: validatedData.chatId,
          userId: userId // Check against DB userId
        },
        include: {
          messages: {
            select: { id: true }
          }
        }
      });
      
      if (!chat) {
        // Check if chat exists at all before throwing auth error
        const chatExists = await db.chat.findUnique({ where: { id: validatedData.chatId } });
        if (!chatExists) throw ApiError.notFound(ResourceType.CHAT);
        // If chat exists but user doesn't own it
        throw ApiError.unauthorized('You do not own this chat.');
      }
      
      // Calculate expiration date if provided
      let expiresAt = null;
      if (validatedData.expiresIn && validatedData.expiresIn !== 'never') {
        expiresAt = new Date();
        if (validatedData.expiresIn === '1d') {
          expiresAt.setDate(expiresAt.getDate() + 1);
        } else if (validatedData.expiresIn === '7d') {
          expiresAt.setDate(expiresAt.getDate() + 7);
        } else if (validatedData.expiresIn === '30d') {
          expiresAt.setDate(expiresAt.getDate() + 30);
        }
      }
      
      // Create a new shared link
      const accessToken = randomUUID().replace(/-/g, '');
      const sharedLink = await db.sharedLink.create({
        data: {
          chatId: chat.id,
          ownerId: userId,
          accessToken,
          messageCountAtShare: chat.messages.length,
          expiresAt
        }
      });
      
      // Return the formatted response
      return {
        id: sharedLink.id,
        chatId: sharedLink.chatId,
        chatTitle: chat.title,
        accessToken: sharedLink.accessToken,
        messageCountAtShare: sharedLink.messageCountAtShare,
        url: `/share/${sharedLink.accessToken}`,
        createdAt: sharedLink.createdAt,
        updatedAt: sharedLink.updatedAt,
        expiresAt: sharedLink.expiresAt,
        isActive: sharedLink.isActive
      };
    } catch (error) {
      console.error('[ShareService.createSharedLink] Error creating shared link:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to create shared link');
    }
  }
  
  /**
   * Get all shared links for a user
   */
  async getUserSharedLinks(userId: string): Promise<SharedLinkResponse[]> {
    try {
      // Get all shared links owned by the user (using DB userId)
      const sharedLinks = await db.sharedLink.findMany({
        where: {
          ownerId: userId, // Filter by DB userId
          isActive: true
        },
        include: {
          chat: {
            select: {
              title: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        }
      });
      
      // Format the response
      return sharedLinks.map(link => ({
        id: link.id,
        chatId: link.chatId,
        chatTitle: link.chat.title,
        accessToken: link.accessToken,
        messageCountAtShare: link.messageCountAtShare,
        url: `/share/${link.accessToken}`,
        createdAt: link.createdAt,
        updatedAt: link.updatedAt,
        expiresAt: link.expiresAt,
        isActive: link.isActive
      }));
    } catch (error) {
      console.error('[ShareService.getUserSharedLinks] Error fetching shared links:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to fetch shared links');
    }
  }
  
  /**
   * Get a shared chat by its access token
   */
  async getSharedChat(token: string): Promise<SharedChatContent> {
    try {
      // Find the shared link by token
      const sharedLink = await db.sharedLink.findFirst({
        where: {
          accessToken: token,
          isActive: true,
          // Check if not expired
          OR: [
            { expiresAt: null },
            { expiresAt: { gt: new Date() } }
          ]
        },
        include: {
          chat: {
            select: {
              id: true,
              title: true
            }
          },
          owner: {
            select: {
              id: true
            }
          }
        }
      });
      
      if (!sharedLink) {
        throw ApiError.notFound('Shared chat not found or link has expired');
      }
      
      // Get the messages limited to the count at sharing time
      const messages = await db.chatMessage.findMany({
        where: {
          chatId: sharedLink.chatId
        },
        orderBy: {
          createdAt: 'asc'
        },
        take: sharedLink.messageCountAtShare
      });
      
      return {
        id: sharedLink.id,
        chat: {
          id: sharedLink.chat.id,
          title: sharedLink.chat.title,
          messages: messages.map(msg => ({
            id: msg.id,
            content: msg.content,
            type: msg.type,
            createdAt: msg.createdAt
          }))
        },
        owner: {
          id: sharedLink.owner.id
        },
        messageCountAtShare: sharedLink.messageCountAtShare,
        createdAt: sharedLink.createdAt,
        updatedAt: sharedLink.updatedAt,
        expiresAt: sharedLink.expiresAt
      };
    } catch (error) {
      console.error('[ShareService.getSharedChat] Error fetching shared chat:', error);
      throw error instanceof ApiError ? error : new ApiError(ErrorType.SERVER_ERROR, 'Failed to fetch shared chat');
    }
  }
  
  /**
   * Get current user info for shared chat context
   */
  async getCurrentUserForSharedChat(clerkId: string): Promise<{ id: string, clerkId: string, hideSharedWarning: boolean } | null> {
    try {
      if (!clerkId) return null;
      
      const currentUser = await db.user.findFirst({
        where: { clerkId }
      });
      
      if (!currentUser) return null;
      
      return {
        id: currentUser.id,
        clerkId: currentUser.clerkId,
        hideSharedWarning: currentUser.hideSharedWarning
      };
    } catch (error) {
      console.error('[ShareService.getCurrentUserForSharedChat] Error:', error);
      return null;
    }
  }
}

// Export a singleton instance for use across the application
export const shareService = new ShareService();

// Exports for use in application
export const createSharedLink = (userId: string, data: CreateSharedLinkRequest) => 
  shareService.createSharedLink(userId, data);
export const getUserSharedLinks = (userId: string) => 
  shareService.getUserSharedLinks(userId);
export const getSharedChat = (token: string) => 
  shareService.getSharedChat(token);
export const getCurrentUserForSharedChat = (clerkId: string) => 
  shareService.getCurrentUserForSharedChat(clerkId); 